
## 位运算符
位运算符是指对二进制位从低位到高位对齐后进行运算。

| 符号 | 作用 | 举例 | 个人理解 |
| --- | --- | --- | --- |
| & | 按位与 | $m & $n | 全1为1，否则为0 |
|\| | 按位或 | $m \| $n | 全0为0，有1为1 |
| ^ | 按位异或 | $m ^ $n | 不同为1，相同为0 |
| ~ | 按位取反 | ~$m  |  |
| << | 向左移位 | $m << $n |  |
| >> | 向右移位 | $m >> $n  |  |
 
** 正数的原码，反码、补码都是一样的，负数不一样** 
- 原码：数字的8位 二进制，符号位（第一位）为0表示正数，为1表示负数　　
- 反码：正数反码与原码一样，负数的反码是符号位1不变，整数的每一位二进制数位求反，得到反码　    
- 补码：正数补码与原码一样，负数反码的符号位1不变，按位取反，末尾（最低位）加1；计算机中的运算都是以补码的形式运算的，存储也是补码  　　 
```
补码的特性：　　　　
1、一个负整数（或原码）与其补数（或补码）相加，和为模。　　　　
2、对一个整数的补码再求补码，等于该整数自身。　　　　
3、补码的正零与负零表示方法相同。　　
```
### &运算符
```
<?php
$m = 1;
$n = 2;
$mn = $m & $n;
echo $mn;
```
运行结果为0解释：
将1，2分别转换为二进制（8 位）为
00000001 00000010
在按位与的过程中，按位比较，全1为1，比较结果为00000000，所以输出0。
#### 负数的 & 运算 
以2&-7=？计算为例：
（1）、计算2的补码： 2->原码：00000010->反码：00000010->补码：00000010
（2）、计算-7的补码： -7->原码：10000111->反码：11111000->补码：11111001
（3）、计算2&-7的补码->反码->原码 2&-7补码：00000000->反码：00000000->原码：00000000
（4）、有2&-7原码得到2&-7的值 所以2&-7 = 0| 运算符
```
<?php
$m = 1;
$n = 2;
$mn = $m | $n;
echo $mn;
```
运行结果为3，同样，转换成如上的二进制
00000001 00000010
在按位或的过程中，有1为1，全0为0，则结果为00000011，所以输出3。

### ^运算符
```
<?php
$m = 1;
$n = 2;
$mn = $m ^ $n;
echo $mn;
```
运行结果为3，同样，转换成如上的二进制
00000001 00000010
在按位亦或的过程中，不同为1，相同为0，所以结果为00000011,进而输出3。

### ~运算符
```
<?php
$m = 2;
$m1 = ~$m;
echo $m1;
```
运行结果为-3，此处引人深思。
注：在计算机中，负数以其正值的补码形式表达。
1: 2的32位原码为 0000 0000 0000 0000 0000 0000 0000 0010
2: 按位取反后为 1111 1111 1111 1111 1111 1111 1111 1101
由于最前面的数为1，符号位为1，即为负数，所以，以其正值的补码形式表示为：（反码的符号位不变，按位取反，末尾加1）
1000 0000 0000 0000 0000 0000 0000 0011
所以输出为-3。

### <<运算符
```
<?php
$m = 3;
$m1=$m << 1;
echo $m1;
```
运算结果为6
左移运算的实质是将对应的数据的二进制值逐位左移若干位，并在空出的位置上填0，最高位溢出并舍弃。
3的32位原码为，0000 0000 0000 0000 0000 0000 0000 0011
左移一位：0000 0000 0000 0000 0000 0000 0000 0110
所以为6根据手册描述可以看出位运算可以看出向左移一位，则是实现乘2运算。由于位移操作的运算速度比乘法的 运算速度高很多。因此在处理数据的乘法运算的时，采用位移运算可以获得较快的速度。 
提示 将所有对2的乘法运算转换为位移运算，可提高程序的运行效率。

### >>运算符　　
右移一位，和<<运算符，类似，只不过这个是右移。